Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> expression
Rule 1     expression -> SID + factor
Rule 2     expression -> SID - factor
Rule 3     expression -> expression END
Rule 4     SID -> INT ID ASSIGN NUMBER
Rule 5     SID -> ID ASSIGN expression
Rule 6     expression -> factor
Rule 7     factor -> NUMBER
Rule 8     factor -> SID
Rule 9     BOOL -> expression GREATER NUMBER
Rule 10    BOOL -> expression FEWER NUMBER
Rule 11    judge -> LPAREN BOOL RPAREN
Rule 12    expression -> IF judge LBRACKET expression RBRACKET ELSE LBRACKET expression RBRACKET

Terminals, with rules where they appear

+                    : 1
-                    : 2
ASSIGN               : 4 5
ELSE                 : 12
END                  : 3
FEWER                : 10
GREATER              : 9
ID                   : 4 5
IF                   : 12
INT                  : 4
LBRACKET             : 12 12
LPAREN               : 11
NUMBER               : 4 7 9 10
RBRACKET             : 12 12
RPAREN               : 11
error                : 

Nonterminals, with rules where they appear

BOOL                 : 11
SID                  : 1 2 8
expression           : 3 5 9 10 12 12 0
factor               : 1 2 6
judge                : 12

Parsing method: LALR

state 0

    (0) S' -> . expression
    (1) expression -> . SID + factor
    (2) expression -> . SID - factor
    (3) expression -> . expression END
    (6) expression -> . factor
    (12) expression -> . IF judge LBRACKET expression RBRACKET ELSE LBRACKET expression RBRACKET
    (4) SID -> . INT ID ASSIGN NUMBER
    (5) SID -> . ID ASSIGN expression
    (7) factor -> . NUMBER
    (8) factor -> . SID

    IF              shift and go to state 4
    INT             shift and go to state 5
    ID              shift and go to state 6
    NUMBER          shift and go to state 7

    expression                     shift and go to state 1
    SID                            shift and go to state 2
    factor                         shift and go to state 3

state 1

    (0) S' -> expression .
    (3) expression -> expression . END

    END             shift and go to state 8


state 2

    (1) expression -> SID . + factor
    (2) expression -> SID . - factor
    (8) factor -> SID .

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
    +               shift and go to state 9
    -               shift and go to state 10
    END             reduce using rule 8 (factor -> SID .)
    $end            reduce using rule 8 (factor -> SID .)
    GREATER         reduce using rule 8 (factor -> SID .)
    FEWER           reduce using rule 8 (factor -> SID .)
    RBRACKET        reduce using rule 8 (factor -> SID .)

  ! +               [ reduce using rule 8 (factor -> SID .) ]
  ! -               [ reduce using rule 8 (factor -> SID .) ]


state 3

    (6) expression -> factor .

    END             reduce using rule 6 (expression -> factor .)
    $end            reduce using rule 6 (expression -> factor .)
    GREATER         reduce using rule 6 (expression -> factor .)
    FEWER           reduce using rule 6 (expression -> factor .)
    +               reduce using rule 6 (expression -> factor .)
    -               reduce using rule 6 (expression -> factor .)
    RBRACKET        reduce using rule 6 (expression -> factor .)


state 4

    (12) expression -> IF . judge LBRACKET expression RBRACKET ELSE LBRACKET expression RBRACKET
    (11) judge -> . LPAREN BOOL RPAREN

    LPAREN          shift and go to state 12

    judge                          shift and go to state 11

state 5

    (4) SID -> INT . ID ASSIGN NUMBER

    ID              shift and go to state 13


state 6

    (5) SID -> ID . ASSIGN expression

    ASSIGN          shift and go to state 14


state 7

    (7) factor -> NUMBER .

    END             reduce using rule 7 (factor -> NUMBER .)
    $end            reduce using rule 7 (factor -> NUMBER .)
    GREATER         reduce using rule 7 (factor -> NUMBER .)
    FEWER           reduce using rule 7 (factor -> NUMBER .)
    +               reduce using rule 7 (factor -> NUMBER .)
    -               reduce using rule 7 (factor -> NUMBER .)
    RBRACKET        reduce using rule 7 (factor -> NUMBER .)


state 8

    (3) expression -> expression END .

    END             reduce using rule 3 (expression -> expression END .)
    $end            reduce using rule 3 (expression -> expression END .)
    GREATER         reduce using rule 3 (expression -> expression END .)
    FEWER           reduce using rule 3 (expression -> expression END .)
    +               reduce using rule 3 (expression -> expression END .)
    -               reduce using rule 3 (expression -> expression END .)
    RBRACKET        reduce using rule 3 (expression -> expression END .)


state 9

    (1) expression -> SID + . factor
    (7) factor -> . NUMBER
    (8) factor -> . SID
    (4) SID -> . INT ID ASSIGN NUMBER
    (5) SID -> . ID ASSIGN expression

    NUMBER          shift and go to state 7
    INT             shift and go to state 5
    ID              shift and go to state 6

    SID                            shift and go to state 15
    factor                         shift and go to state 16

state 10

    (2) expression -> SID - . factor
    (7) factor -> . NUMBER
    (8) factor -> . SID
    (4) SID -> . INT ID ASSIGN NUMBER
    (5) SID -> . ID ASSIGN expression

    NUMBER          shift and go to state 7
    INT             shift and go to state 5
    ID              shift and go to state 6

    SID                            shift and go to state 15
    factor                         shift and go to state 17

state 11

    (12) expression -> IF judge . LBRACKET expression RBRACKET ELSE LBRACKET expression RBRACKET

    LBRACKET        shift and go to state 18


state 12

    (11) judge -> LPAREN . BOOL RPAREN
    (9) BOOL -> . expression GREATER NUMBER
    (10) BOOL -> . expression FEWER NUMBER
    (1) expression -> . SID + factor
    (2) expression -> . SID - factor
    (3) expression -> . expression END
    (6) expression -> . factor
    (12) expression -> . IF judge LBRACKET expression RBRACKET ELSE LBRACKET expression RBRACKET
    (4) SID -> . INT ID ASSIGN NUMBER
    (5) SID -> . ID ASSIGN expression
    (7) factor -> . NUMBER
    (8) factor -> . SID

    IF              shift and go to state 4
    INT             shift and go to state 5
    ID              shift and go to state 6
    NUMBER          shift and go to state 7

    BOOL                           shift and go to state 19
    expression                     shift and go to state 20
    SID                            shift and go to state 2
    factor                         shift and go to state 3

state 13

    (4) SID -> INT ID . ASSIGN NUMBER

    ASSIGN          shift and go to state 21


state 14

    (5) SID -> ID ASSIGN . expression
    (1) expression -> . SID + factor
    (2) expression -> . SID - factor
    (3) expression -> . expression END
    (6) expression -> . factor
    (12) expression -> . IF judge LBRACKET expression RBRACKET ELSE LBRACKET expression RBRACKET
    (4) SID -> . INT ID ASSIGN NUMBER
    (5) SID -> . ID ASSIGN expression
    (7) factor -> . NUMBER
    (8) factor -> . SID

    IF              shift and go to state 4
    INT             shift and go to state 5
    ID              shift and go to state 6
    NUMBER          shift and go to state 7

    expression                     shift and go to state 22
    SID                            shift and go to state 2
    factor                         shift and go to state 3

state 15

    (8) factor -> SID .

    END             reduce using rule 8 (factor -> SID .)
    $end            reduce using rule 8 (factor -> SID .)
    GREATER         reduce using rule 8 (factor -> SID .)
    FEWER           reduce using rule 8 (factor -> SID .)
    +               reduce using rule 8 (factor -> SID .)
    -               reduce using rule 8 (factor -> SID .)
    RBRACKET        reduce using rule 8 (factor -> SID .)


state 16

    (1) expression -> SID + factor .

    END             reduce using rule 1 (expression -> SID + factor .)
    $end            reduce using rule 1 (expression -> SID + factor .)
    GREATER         reduce using rule 1 (expression -> SID + factor .)
    FEWER           reduce using rule 1 (expression -> SID + factor .)
    +               reduce using rule 1 (expression -> SID + factor .)
    -               reduce using rule 1 (expression -> SID + factor .)
    RBRACKET        reduce using rule 1 (expression -> SID + factor .)


state 17

    (2) expression -> SID - factor .

    END             reduce using rule 2 (expression -> SID - factor .)
    $end            reduce using rule 2 (expression -> SID - factor .)
    GREATER         reduce using rule 2 (expression -> SID - factor .)
    FEWER           reduce using rule 2 (expression -> SID - factor .)
    +               reduce using rule 2 (expression -> SID - factor .)
    -               reduce using rule 2 (expression -> SID - factor .)
    RBRACKET        reduce using rule 2 (expression -> SID - factor .)


state 18

    (12) expression -> IF judge LBRACKET . expression RBRACKET ELSE LBRACKET expression RBRACKET
    (1) expression -> . SID + factor
    (2) expression -> . SID - factor
    (3) expression -> . expression END
    (6) expression -> . factor
    (12) expression -> . IF judge LBRACKET expression RBRACKET ELSE LBRACKET expression RBRACKET
    (4) SID -> . INT ID ASSIGN NUMBER
    (5) SID -> . ID ASSIGN expression
    (7) factor -> . NUMBER
    (8) factor -> . SID

    IF              shift and go to state 4
    INT             shift and go to state 5
    ID              shift and go to state 6
    NUMBER          shift and go to state 7

    expression                     shift and go to state 23
    SID                            shift and go to state 2
    factor                         shift and go to state 3

state 19

    (11) judge -> LPAREN BOOL . RPAREN

    RPAREN          shift and go to state 24


state 20

    (9) BOOL -> expression . GREATER NUMBER
    (10) BOOL -> expression . FEWER NUMBER
    (3) expression -> expression . END

    GREATER         shift and go to state 25
    FEWER           shift and go to state 26
    END             shift and go to state 8


state 21

    (4) SID -> INT ID ASSIGN . NUMBER

    NUMBER          shift and go to state 27


state 22

    (5) SID -> ID ASSIGN expression .
    (3) expression -> expression . END

  ! shift/reduce conflict for END resolved as shift
    +               reduce using rule 5 (SID -> ID ASSIGN expression .)
    -               reduce using rule 5 (SID -> ID ASSIGN expression .)
    $end            reduce using rule 5 (SID -> ID ASSIGN expression .)
    GREATER         reduce using rule 5 (SID -> ID ASSIGN expression .)
    FEWER           reduce using rule 5 (SID -> ID ASSIGN expression .)
    RBRACKET        reduce using rule 5 (SID -> ID ASSIGN expression .)
    END             shift and go to state 8

  ! END             [ reduce using rule 5 (SID -> ID ASSIGN expression .) ]


state 23

    (12) expression -> IF judge LBRACKET expression . RBRACKET ELSE LBRACKET expression RBRACKET
    (3) expression -> expression . END

    RBRACKET        shift and go to state 28
    END             shift and go to state 8


state 24

    (11) judge -> LPAREN BOOL RPAREN .

    LBRACKET        reduce using rule 11 (judge -> LPAREN BOOL RPAREN .)


state 25

    (9) BOOL -> expression GREATER . NUMBER

    NUMBER          shift and go to state 29


state 26

    (10) BOOL -> expression FEWER . NUMBER

    NUMBER          shift and go to state 30


state 27

    (4) SID -> INT ID ASSIGN NUMBER .

    +               reduce using rule 4 (SID -> INT ID ASSIGN NUMBER .)
    -               reduce using rule 4 (SID -> INT ID ASSIGN NUMBER .)
    END             reduce using rule 4 (SID -> INT ID ASSIGN NUMBER .)
    $end            reduce using rule 4 (SID -> INT ID ASSIGN NUMBER .)
    GREATER         reduce using rule 4 (SID -> INT ID ASSIGN NUMBER .)
    FEWER           reduce using rule 4 (SID -> INT ID ASSIGN NUMBER .)
    RBRACKET        reduce using rule 4 (SID -> INT ID ASSIGN NUMBER .)


state 28

    (12) expression -> IF judge LBRACKET expression RBRACKET . ELSE LBRACKET expression RBRACKET

    ELSE            shift and go to state 31


state 29

    (9) BOOL -> expression GREATER NUMBER .

    RPAREN          reduce using rule 9 (BOOL -> expression GREATER NUMBER .)


state 30

    (10) BOOL -> expression FEWER NUMBER .

    RPAREN          reduce using rule 10 (BOOL -> expression FEWER NUMBER .)


state 31

    (12) expression -> IF judge LBRACKET expression RBRACKET ELSE . LBRACKET expression RBRACKET

    LBRACKET        shift and go to state 32


state 32

    (12) expression -> IF judge LBRACKET expression RBRACKET ELSE LBRACKET . expression RBRACKET
    (1) expression -> . SID + factor
    (2) expression -> . SID - factor
    (3) expression -> . expression END
    (6) expression -> . factor
    (12) expression -> . IF judge LBRACKET expression RBRACKET ELSE LBRACKET expression RBRACKET
    (4) SID -> . INT ID ASSIGN NUMBER
    (5) SID -> . ID ASSIGN expression
    (7) factor -> . NUMBER
    (8) factor -> . SID

    IF              shift and go to state 4
    INT             shift and go to state 5
    ID              shift and go to state 6
    NUMBER          shift and go to state 7

    expression                     shift and go to state 33
    SID                            shift and go to state 2
    factor                         shift and go to state 3

state 33

    (12) expression -> IF judge LBRACKET expression RBRACKET ELSE LBRACKET expression . RBRACKET
    (3) expression -> expression . END

    RBRACKET        shift and go to state 34
    END             shift and go to state 8


state 34

    (12) expression -> IF judge LBRACKET expression RBRACKET ELSE LBRACKET expression RBRACKET .

    END             reduce using rule 12 (expression -> IF judge LBRACKET expression RBRACKET ELSE LBRACKET expression RBRACKET .)
    $end            reduce using rule 12 (expression -> IF judge LBRACKET expression RBRACKET ELSE LBRACKET expression RBRACKET .)
    GREATER         reduce using rule 12 (expression -> IF judge LBRACKET expression RBRACKET ELSE LBRACKET expression RBRACKET .)
    FEWER           reduce using rule 12 (expression -> IF judge LBRACKET expression RBRACKET ELSE LBRACKET expression RBRACKET .)
    +               reduce using rule 12 (expression -> IF judge LBRACKET expression RBRACKET ELSE LBRACKET expression RBRACKET .)
    -               reduce using rule 12 (expression -> IF judge LBRACKET expression RBRACKET ELSE LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 12 (expression -> IF judge LBRACKET expression RBRACKET ELSE LBRACKET expression RBRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for + in state 2 resolved as shift
WARNING: shift/reduce conflict for - in state 2 resolved as shift
WARNING: shift/reduce conflict for END in state 22 resolved as shift
